$date
	Tue Jun 25 17:46:18 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU $end
$var wire 32 ! write_value [31:0] $end
$var wire 3 " write_reg [2:0] $end
$var wire 32 # regBvalue [31:0] $end
$var wire 32 $ reg1val [31:0] $end
$var wire 32 % pcPlusOne [31:0] $end
$var wire 32 & pcInput [31:0] $end
$var wire 32 ' pcCurrent [31:0] $end
$var wire 32 ( offsetExtended [31:0] $end
$var wire 32 ) memResult [31:0] $end
$var wire 32 * instruction [31:0] $end
$var wire 1 + clk $end
$var wire 32 , aluValB [31:0] $end
$var wire 32 - aluValA [31:0] $end
$var wire 32 . aluResult [31:0] $end
$var wire 1 / CONTROL_WRITE_REG $end
$var wire 1 0 CONTROL_WRITE_DATA $end
$var wire 2 1 CONTROL_OPERATION [1:0] $end
$var wire 1 2 CONTROL_MEM_ACCESS $end
$var wire 1 3 CONTROL_JALR $end
$var wire 1 4 CONTROL_HALT $end
$var wire 1 5 CONTROL_ENABLE_REG_WRITE $end
$var wire 1 6 CONTROL_ENABLE_MEM_WRITE $end
$var wire 1 7 CONTROL_BEQ $end
$var wire 1 8 CONTROL_ALUvalB $end
$var reg 1 9 pc_reset $end
$scope module PC $end
$var wire 1 9 reset $end
$var wire 32 : pcInput [31:0] $end
$var wire 1 + clk $end
$var wire 1 4 CONTROL_HALT $end
$var reg 32 ; pcCurrent [31:0] $end
$var reg 32 < pcPlusOne [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 = aluValB [31:0] $end
$var wire 32 > aluValA [31:0] $end
$var wire 2 ? CONTROL_OPERATION [1:0] $end
$var reg 1 7 CONTROL_BEQ $end
$var reg 32 @ aluResult [31:0] $end
$upscope $end
$scope module cRom $end
$var wire 3 A opcode [2:0] $end
$var wire 32 B pcCurrent [31:0] $end
$var wire 1 + clk $end
$var parameter 3 C OP_ADD $end
$var parameter 3 D OP_BEQ $end
$var parameter 3 E OP_HALT $end
$var parameter 3 F OP_JALR $end
$var parameter 3 G OP_LW $end
$var parameter 3 H OP_NOOP $end
$var parameter 3 I OP_NOR $end
$var parameter 3 J OP_SW $end
$var reg 1 8 CONTROL_ALUvalB $end
$var reg 1 6 CONTROL_ENABLE_MEM_WRITE $end
$var reg 1 5 CONTROL_ENABLE_REG_WRITE $end
$var reg 1 4 CONTROL_HALT $end
$var reg 1 3 CONTROL_JALR $end
$var reg 1 2 CONTROL_MEM_ACCESS $end
$var reg 2 K CONTROL_OPERATION [1:0] $end
$var reg 1 0 CONTROL_WRITE_DATA $end
$var reg 1 / CONTROL_WRITE_REG $end
$upscope $end
$scope module clock $end
$var reg 1 + clk $end
$upscope $end
$scope module dataM $end
$var wire 1 6 CONTROL_ENABLE_MEM_WRITE $end
$var wire 1 2 CONTROL_MEM_ACCESS $end
$var wire 32 L aluResult [31:0] $end
$var wire 32 M regBvalue [31:0] $end
$var reg 32 N memResult [31:0] $end
$var integer 32 O ii [31:0] $end
$upscope $end
$scope module instrM $end
$var wire 32 P pcCurrent [31:0] $end
$var reg 32 Q instr [31:0] $end
$upscope $end
$scope module pM $end
$var wire 1 7 CONTROL_BEQ $end
$var wire 1 3 CONTROL_JALR $end
$var wire 32 R pcCurrent [31:0] $end
$var wire 32 S pcPlusOne [31:0] $end
$var wire 32 T offsetExtended [31:0] $end
$var wire 32 U aluValA [31:0] $end
$var reg 32 V pcOutput [31:0] $end
$upscope $end
$scope module regM $end
$var wire 1 5 CONTROL_ENABLE_REG_WRITE $end
$var wire 3 W read_regA [2:0] $end
$var wire 3 X read_regB [2:0] $end
$var wire 32 Y write_value [31:0] $end
$var wire 3 Z write_reg [2:0] $end
$var reg 32 [ aluValA [31:0] $end
$var reg 32 \ reg1val [31:0] $end
$var reg 32 ] regBvalue [31:0] $end
$var integer 32 ^ ii [31:0] $end
$upscope $end
$scope module sExtend $end
$var wire 16 _ offset [15:0] $end
$var reg 32 ` offsetExtended [31:0] $end
$upscope $end
$scope module vbMux $end
$var wire 1 8 CONTROL_ALUvalB $end
$var wire 32 a offsetExtended [31:0] $end
$var wire 32 b regBvalue [31:0] $end
$var reg 32 c aluValB [31:0] $end
$upscope $end
$scope module wdMux $end
$var wire 1 0 CONTROL_WRITE_DATA $end
$var wire 32 d aluResult [31:0] $end
$var wire 32 e memResult [31:0] $end
$var wire 32 f pcPlusOne [31:0] $end
$var reg 32 g write_value [31:0] $end
$upscope $end
$scope module wrMux $end
$var wire 1 / CONTROL_WRITE_REG $end
$var wire 3 h destReg [2:0] $end
$var wire 3 i regB [2:0] $end
$var reg 3 j write_reg [2:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b11 J
b1 I
b111 H
b10 G
b101 F
b110 E
b100 D
b0 C
$end
#0
$dumpvars
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
b0xxxxxxxx b
bx a
bx `
bx _
b1000 ^
b0xxxxxxxx ]
b0 \
b0xxxxxxxx [
bx Z
bx Y
bx X
bx W
bx V
b0xxxxxxxx U
bx T
bx S
bx R
bx Q
bx P
b1000000 O
bx N
b0xxxxxxxx M
bx L
b0 K
bx B
bx A
bx @
b0 ?
b0xxxxxxxx >
bx =
bx <
bx ;
bx :
19
08
07
06
05
04
03
02
b0 1
00
0/
bx .
b0xxxxxxxx -
bx ,
0+
bx *
bx )
bx (
bx '
bx &
bx %
b0 $
b0xxxxxxxx #
bx "
bx !
$end
#100
b1010 .
b1010 @
b1010 L
b1010 d
b1010 ,
b1010 =
b1010 c
b1010 (
b1010 T
b1010 `
b1010 a
b1 "
b1 Z
b1 j
b0 #
b0 M
b0 ]
b0 b
b0 -
b0 >
b0 U
b0 [
b10 A
b1 X
b0 W
b1010 _
b10 h
b1 i
b100000010000000000001010 *
b100000010000000000001010 Q
b1 &
b1 :
b1 V
b1 %
b1 <
b1 S
b1 f
b0 '
b0 ;
b0 B
b0 P
b0 R
1+
#150
09
#200
b101 !
b101 Y
b101 g
b101 )
b101 N
b101 e
b101 $
b101 \
b101 #
b101 M
b101 ]
b101 b
12
15
0+
#300
b1 !
b1 Y
b1 g
b1 )
b1 N
b1 e
b1001 .
b1001 @
b1001 L
b1001 d
b1001 ,
b1001 =
b1001 c
b1001 (
b1001 T
b1001 `
b1001 a
b10 "
b10 Z
b10 j
b1 #
b1 M
b1 ]
b1 b
b10 X
b1001 _
b1 h
b10 i
b100000100000000000001001 *
b100000100000000000001001 Q
b10 &
b10 :
b10 V
b10 %
b10 <
b10 S
b10 f
b1 '
b1 ;
b1 B
b1 P
b1 R
1+
#400
0+
#500
b0 #
b0 M
b0 ]
b0 b
b0 !
b0 Y
b0 g
b0 )
b0 N
b0 e
b1 ,
b1 =
b1 c
b110 .
b110 @
b110 L
b110 d
b1 (
b1 T
b1 `
b1 a
b101 -
b101 >
b101 U
b101 [
b0 A
b1 W
b1 _
b10100000000000000001 *
b10100000000000000001 Q
b11 &
b11 :
b11 V
b11 %
b11 <
b11 S
b11 f
b10 '
b10 ;
b10 B
b10 P
b10 R
1+
#600
b110 .
b110 @
b110 L
b110 d
b110 $
b110 \
b110 -
b110 >
b110 U
b110 [
b110 !
b110 Y
b110 g
b1 "
b1 Z
b1 j
b0 ,
b0 =
b0 c
02
10
1/
18
0+
#700
