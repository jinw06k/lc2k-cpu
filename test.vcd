$date
	Tue Jun 25 17:46:18 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU $end
$var wire 32 ! write_value [31:0] $end
$var wire 3 " write_reg [2:0] $end
$var wire 32 # regBvalue [31:0] $end
$var wire 32 $ reg1val [31:0] $end
$var wire 32 % pcPlusOne [31:0] $end
$var wire 32 & pcInput [31:0] $end
$var wire 32 ' pcCurrent [31:0] $end
$var wire 32 ( offsetExtended [31:0] $end
$var wire 32 ) memResult [31:0] $end
$var wire 32 * instruction [31:0] $end
$var wire 1 + clk $end
$var wire 32 , aluValB [31:0] $end
$var wire 32 - aluValA [31:0] $end
$var wire 32 . aluResult [31:0] $end
$var wire 1 / CONTROL_WRITE_REG $end
$var wire 1 0 CONTROL_WRITE_DATA $end
$var wire 2 1 CONTROL_OPERATION [1:0] $end
$var wire 1 2 CONTROL_MEM_ACCESS $end
$var wire 1 3 CONTROL_JALR $end
$var wire 1 4 CONTROL_HALT $end
$var wire 1 5 CONTROL_ENABLE_REG_WRITE $end
$var wire 1 6 CONTROL_ENABLE_MEM_WRITE $end
$var wire 1 7 CONTROL_BEQ $end
$var wire 1 8 CONTROL_ALUvalB $end
$var reg 1 9 pc_reset $end
$scope module PC $end
$var wire 1 9 reset $end
$var wire 32 : pcInput [31:0] $end
$var wire 1 + clk $end
$var wire 1 4 CONTROL_HALT $end
$var reg 32 ; pcCurrent [31:0] $end
$var reg 32 < pcPlusOne [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 = aluValB [31:0] $end
$var wire 32 > aluValA [31:0] $end
$var wire 2 ? CONTROL_OPERATION [1:0] $end
$var reg 1 7 CONTROL_BEQ $end
$var reg 32 @ aluResult [31:0] $end
$upscope $end
$scope module cRom $end
$var wire 3 A opcode [2:0] $end
$var wire 32 B pcCurrent [31:0] $end
$var wire 1 + clk $end
$var parameter 3 C OP_ADD $end
$var parameter 3 D OP_BEQ $end
$var parameter 3 E OP_HALT $end
$var parameter 3 F OP_JALR $end
$var parameter 3 G OP_LW $end
$var parameter 3 H OP_NOOP $end
$var parameter 3 I OP_NOR $end
$var parameter 3 J OP_SW $end
$var reg 1 8 CONTROL_ALUvalB $end
$var reg 1 6 CONTROL_ENABLE_MEM_WRITE $end
$var reg 1 5 CONTROL_ENABLE_REG_WRITE $end
$var reg 1 4 CONTROL_HALT $end
$var reg 1 3 CONTROL_JALR $end
$var reg 1 2 CONTROL_MEM_ACCESS $end
$var reg 2 K CONTROL_OPERATION [1:0] $end
$var reg 1 0 CONTROL_WRITE_DATA $end
$var reg 1 / CONTROL_WRITE_REG $end
$upscope $end
$scope module clock $end
$var reg 1 + clk $end
$upscope $end
$scope module dataM $end
$var wire 1 6 CONTROL_ENABLE_MEM_WRITE $end
$var wire 1 2 CONTROL_MEM_ACCESS $end
$var wire 32 L aluResult [31:0] $end
$var wire 32 M regBvalue [31:0] $end
$var reg 32 N memResult [31:0] $end
$var integer 32 O ii [31:0] $end
$upscope $end
$scope module instrM $end
$var wire 32 P pcCurrent [31:0] $end
$var reg 32 Q instr [31:0] $end
$upscope $end
$scope module pM $end
$var wire 1 7 CONTROL_BEQ $end
$var wire 1 3 CONTROL_JALR $end
$var wire 32 R pcCurrent [31:0] $end
$var wire 32 S pcPlusOne [31:0] $end
$var wire 32 T offsetExtended [31:0] $end
$var wire 32 U aluValA [31:0] $end
$var reg 32 V pcOutput [31:0] $end
$upscope $end
$scope module regM $end
$var wire 1 5 CONTROL_ENABLE_REG_WRITE $end
$var wire 3 W read_regA [2:0] $end
$var wire 3 X read_regB [2:0] $end
$var wire 32 Y write_value [31:0] $end
$var wire 3 Z write_reg [2:0] $end
$var reg 32 [ aluValA [31:0] $end
$var reg 32 \ reg1val [31:0] $end
$var reg 32 ] regBvalue [31:0] $end
$var integer 32 ^ ii [31:0] $end
$upscope $end
$scope module sExtend $end
$var wire 16 _ offset [15:0] $end
$var reg 32 ` offsetExtended [31:0] $end
$upscope $end
$scope module vbMux $end
$var wire 1 8 CONTROL_ALUvalB $end
$var wire 32 a offsetExtended [31:0] $end
$var wire 32 b regBvalue [31:0] $end
$var reg 32 c aluValB [31:0] $end
$upscope $end
$scope module wdMux $end
$var wire 1 0 CONTROL_WRITE_DATA $end
$var wire 32 d aluResult [31:0] $end
$var wire 32 e memResult [31:0] $end
$var wire 32 f pcPlusOne [31:0] $end
$var reg 32 g write_value [31:0] $end
$upscope $end
$scope module wrMux $end
$var wire 1 / CONTROL_WRITE_REG $end
$var wire 3 h destReg [2:0] $end
$var wire 3 i regB [2:0] $end
$var reg 3 j write_reg [2:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b11 J
b1 I
b111 H
b10 G
b101 F
b110 E
b100 D
b0 C
$end
#0
$du