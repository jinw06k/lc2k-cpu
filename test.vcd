$date
	Wed Jun 26 16:49:56 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU $end
$var wire 32 ! write_value [31:0] $end
$var wire 3 " write_reg [2:0] $end
$var wire 1 # temp $end
$var wire 32 $ regBvalue [31:0] $end
$var wire 32 % reg1val [31:0] $end
$var wire 32 & pcPlusOne [31:0] $end
$var wire 32 ' pcInput [31:0] $end
$var wire 32 ( pcCurrent [31:0] $end
$var wire 32 ) offsetExtended [31:0] $end
$var wire 32 * memResult [31:0] $end
$var wire 32 + instruction [31:0] $end
$var wire 1 , clk $end
$var wire 32 - aluValB [31:0] $end
$var wire 32 . aluValA [31:0] $end
$var wire 32 / aluResult [31:0] $end
$var wire 1 0 CONTROL_WRITE_REG $end
$var wire 1 1 CONTROL_WRITE_DATA $end
$var wire 2 2 CONTROL_OPERATION [1:0] $end
$var wire 1 3 CONTROL_MEM_ACCESS $end
$var wire 1 4 CONTROL_JALR $end
$var wire 1 5 CONTROL_HALT $end
$var wire 1 6 CONTROL_ENABLE_REG_WRITE $end
$var wire 1 7 CONTROL_ENABLE_MEM_WRITE $end
$var wire 1 8 CONTROL_BEQ $end
$var wire 1 9 CONTROL_ALUvalB $end
$scope module PC $end
$var wire 32 : pcInput [31:0] $end
$var wire 1 , clk $end
$var wire 1 5 CONTROL_HALT $end
$var reg 32 ; pcCurrent [31:0] $end
$var reg 32 < pcPlusOne [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 = aluValB [31:0] $end
$var wire 32 > aluValA [31:0] $end
$var wire 2 ? CONTROL_OPERATION [1:0] $end
$var reg 1 8 CONTROL_BEQ $end
$var reg 32 @ aluResult [31:0] $end
$upscope $end
$scope module cRom $end
$var wire 3 A opcode [2:0] $end
$var wire 32 B pcCurrent [31:0] $end
$var wire 32 C instruction [31:0] $end
$var wire 1 , clk $end
$var parameter 3 D OP_ADD $end
$var parameter 3 E OP_BEQ $end
$var parameter 3 F OP_HALT $end
$var parameter 3 G OP_JALR $end
$var parameter 3 H OP_LW $end
$var parameter 3 I OP_NOOP $end
$var parameter 3 J OP_NOR $end
$var parameter 3 K OP_SW $end
$var reg 1 9 CONTROL_ALUvalB $end
$var reg 1 7 CONTROL_ENABLE_MEM_WRITE $end
$var reg 1 6 CONTROL_ENABLE_REG_WRITE $end
$var reg 1 5 CONTROL_HALT $end
$var reg 1 4 CONTROL_JALR $end
$var reg 1 3 CONTROL_MEM_ACCESS $end
$var reg 2 L CONTROL_OPERATION [1:0] $end
$var reg 1 1 CONTROL_WRITE_DATA $end
$var reg 1 0 CONTROL_WRITE_REG $end
$var reg 1 # temp $end
$upscope $end
$scope module clock $end
$var reg 1 , clk $end
$upscope $end
$scope module dataM $end
$var wire 1 7 CONTROL_ENABLE_MEM_WRITE $end
$var wire 1 3 CONTROL_MEM_ACCESS $end
$var wire 32 M aluResult [31:0] $end
$var wire 32 N regBvalue [31:0] $end
$var reg 32 O memResult [31:0] $end
$var integer 32 P ii [31:0] $end
$upscope $end
$scope module instrM $end
$var wire 1 , clk $end
$var wire 32 Q instr [31:0] $end
$var wire 32 R pcCurrent [31:0] $end
$upscope $end
$scope module pM $end
$var wire 1 8 CONTROL_BEQ $end
$var wire 1 4 CONTROL_JALR $end
$var wire 32 S pcCurrent [31:0] $end
$var wire 32 T pcPlusOne [31:0] $end
$var wire 32 U offsetExtended [31:0] $end
$var wire 32 V aluValA [31:0] $end
$var reg 32 W pcOutput [31:0] $end
$upscope $end
$scope module regM $end
$var wire 1 6 CONTROL_ENABLE_REG_WRITE $end
$var wire 3 X read_regA [2:0] $end
$var wire 3 Y read_regB [2:0] $end
$var wire 32 Z write_value [31:0] $end
$var wire 3 [ write_reg [2:0] $end
$var reg 32 \ aluValA [31:0] $end
$var reg 32 ] reg1val [31:0] $end
$var reg 32 ^ regBvalue [31:0] $end
$var integer 32 _ ii [31:0] $end
$upscope $end
$scope module sExtend $end
$var wire 16 ` offset [15:0] $end
$var reg 32 a offsetExtended [31:0] $end
$upscope $end
$scope module vbMux $end
$var wire 1 9 CONTROL_ALUvalB $end
$var wire 32 b offsetExtended [31:0] $end
$var wire 32 c regBvalue [31:0] $end
$var reg 32 d aluValB [31:0] $end
$upscope $end
$scope module wdMux $end
$var wire 1 1 CONTROL_WRITE_DATA $end
$var wire 32 e aluResult [31:0] $end
$var wire 32 f memResult [31:0] $end
$var wire 32 g pcPlusOne [31:0] $end
$var reg 32 h write_value [31:0] $end
$upscope $end
$scope module wrMux $end
$var wire 1 0 CONTROL_WRITE_REG $end
$var wire 3 i destReg [2:0] $end
$var wire 3 j regB [2:0] $end
$var reg 3 k write_reg [2:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b11 K
b1 J
b111 I
b10 H
b101 G
b110 F
b100 E
b0 D
$end
#0
$dumpvars
b1 k
b1 j
b10 i
b101 h
b1 g
b101 f
b1010 e
b1010 d
b101 c
b1010 b
b1010 a
b1010 `
b1000 _
b101 ^
b101 ]
b0 \
b1 [
b101 Z
b1 Y
b0 X
b1 W
b0 V
b1010 U
b1 T
b0 S
b0 R
b100000010000000000001010 Q
b1000000 P
b101 O
b101 N
b1010 M
b0 L
b100000010000000000001010 C
b0 B
b10 A
b1010 @
b0 ?
b0 >
b1010 =
b1 <
b0 ;
b1 :
09
08
07
16
05
04
13
b0 2
01
00
b1010 /
b0 .
b1010 -
1,
b100000010000000000001010 +
b101 *
b1010 )
b0 (
b1 '
b1 &
b101 %
b101 $
x#
b1 "
b101 !
$end
#100
0,
#200
